use std::fmt::Write;

#[derive(Clone, Copy, Debug)]
pub enum ExportFormat {
    CamillaDSP,
    ParametricEQ,
    REW,
}

/// Single filter parameter for export
#[derive(Clone, Debug)]
pub struct FilterParam {
    pub filter_type: String,
    pub frequency: f64,
    pub gain: f64,
    pub q: f64,
}

/// Export filter parameters to various formats
pub fn export_filters(
    filters: &[FilterParam],
    format: ExportFormat,
    sample_rate: u32,
) -> Result<String, String> {
    match format {
        ExportFormat::CamillaDSP => export_camilladsp(filters, sample_rate),
        ExportFormat::ParametricEQ => export_parametric_eq(filters),
        ExportFormat::REW => export_rew(filters),
    }
}

fn export_camilladsp(filters: &[FilterParam], _sample_rate: u32) -> Result<String, String> {
    let mut output = String::new();

    writeln!(&mut output, "# CamillaDSP Configuration").map_err(|e| e.to_string())?;
    writeln!(&mut output, "# Generated by AutoEQ").map_err(|e| e.to_string())?;
    writeln!(&mut output).map_err(|e| e.to_string())?;
    writeln!(&mut output, "filters:").map_err(|e| e.to_string())?;

    for (i, filter) in filters.iter().enumerate() {
        writeln!(&mut output, "  filter{}:", i + 1).map_err(|e| e.to_string())?;
        writeln!(
            &mut output,
            "    type: {}",
            map_filter_type(&filter.filter_type)
        )
        .map_err(|e| e.to_string())?;
        writeln!(&mut output, "    freq: {}", filter.frequency).map_err(|e| e.to_string())?;
        writeln!(&mut output, "    gain: {}", filter.gain).map_err(|e| e.to_string())?;
        writeln!(&mut output, "    q: {}", filter.q).map_err(|e| e.to_string())?;
    }

    Ok(output)
}

fn export_parametric_eq(filters: &[FilterParam]) -> Result<String, String> {
    let mut output = String::new();

    writeln!(&mut output, "# Parametric EQ Settings").map_err(|e| e.to_string())?;
    writeln!(&mut output, "# Generated by AutoEQ").map_err(|e| e.to_string())?;
    writeln!(&mut output).map_err(|e| e.to_string())?;
    writeln!(&mut output, "Type\tFreq\tGain\tQ").map_err(|e| e.to_string())?;

    for filter in filters {
        writeln!(
            &mut output,
            "{}\t{:.1}\t{:.2}\t{:.3}",
            filter.filter_type, filter.frequency, filter.gain, filter.q
        )
        .map_err(|e| e.to_string())?;
    }

    Ok(output)
}

fn export_rew(filters: &[FilterParam]) -> Result<String, String> {
    let mut output = String::new();

    writeln!(&mut output, "# Room EQ Wizard Filter Export").map_err(|e| e.to_string())?;
    writeln!(&mut output, "# Generated by AutoEQ").map_err(|e| e.to_string())?;
    writeln!(&mut output).map_err(|e| e.to_string())?;

    for (i, filter) in filters.iter().enumerate() {
        writeln!(
            &mut output,
            "Filter {}: ON {} Fc {} Hz Gain {} dB Q {}",
            i + 1,
            map_filter_type(&filter.filter_type),
            filter.frequency,
            filter.gain,
            filter.q
        )
        .map_err(|e| e.to_string())?;
    }

    Ok(output)
}

fn map_filter_type(filter_type: &str) -> &str {
    match filter_type.to_uppercase().as_str() {
        "PK" => "Peaking",
        "HP" => "HighPass",
        "LP" => "LowPass",
        "HS" => "HighShelf",
        "LS" => "LowShelf",
        _ => filter_type,
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    fn get_test_filters() -> Vec<FilterParam> {
        vec![
            FilterParam {
                filter_type: "PK".to_string(),
                frequency: 100.0,
                gain: 2.5,
                q: 1.0,
            },
            FilterParam {
                filter_type: "PK".to_string(),
                frequency: 1000.0,
                gain: -3.0,
                q: 2.0,
            },
        ]
    }

    #[test]
    fn test_export_camilladsp() {
        let filters = get_test_filters();
        let result = export_camilladsp(&filters, 48000);
        assert!(result.is_ok());
        let output = result.unwrap();
        assert!(output.contains("CamillaDSP"));
        assert!(output.contains("filter1:"));
        assert!(output.contains("freq: 100"));
        assert!(output.contains("gain: 2.5"));
    }

    #[test]
    fn test_export_parametric_eq() {
        let filters = get_test_filters();
        let result = export_parametric_eq(&filters);
        assert!(result.is_ok());
        let output = result.unwrap();
        assert!(output.contains("Parametric EQ"));
        assert!(output.contains("100.0"));
        assert!(output.contains("-3.00"));
    }

    #[test]
    fn test_export_rew() {
        let filters = get_test_filters();
        let result = export_rew(&filters);
        assert!(result.is_ok());
        let output = result.unwrap();
        assert!(output.contains("Room EQ Wizard"));
        assert!(output.contains("Filter 1:"));
        assert!(output.contains("Fc 100"));
    }
}
