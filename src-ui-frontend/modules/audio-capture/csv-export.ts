// CSV export utility for captured audio data

export interface CaptureMetadata {
  timestamp: Date;
  deviceName: string;
  signalType: "sweep" | "white" | "pink";
  duration: number;
  sampleRate: number;
  outputChannel: string;
}

export interface ExportData {
  frequencies: number[];
  rawMagnitudes: number[];
  smoothedMagnitudes: number[];
  rawPhase?: number[]; // Phase data in degrees
  smoothedPhase?: number[]; // Smoothed phase data in degrees
  metadata: CaptureMetadata;
}

export class CSVExporter {
  /**
   * Export captured data to CSV format and trigger download
   */
  public static exportToCSV(data: ExportData): void {
    const csv = this.generateCSV(data);
    const filename = this.generateFilename(data.metadata);
    this.triggerDownload(csv, filename);
  }

  /**
   * Generate CSV content from capture data
   */
  private static generateCSV(data: ExportData): string {
    const lines: string[] = [];

    // Add header comments with metadata
    lines.push("# AutoEQ Audio Capture Data");
    lines.push(`# Capture Date: ${data.metadata.timestamp.toISOString()}`);
    lines.push(`# Device: ${data.metadata.deviceName}`);
    lines.push(`# Signal Type: ${data.metadata.signalType}`);
    lines.push(`# Duration: ${data.metadata.duration}s`);
    lines.push(`# Sample Rate: ${data.metadata.sampleRate}Hz`);
    lines.push(`# Output Channel: ${data.metadata.outputChannel}`);
    lines.push(`# Generated by AutoEQ App`);
    lines.push("");

    // Column headers
    const hasPhase = data.rawPhase && data.smoothedPhase;
    if (hasPhase) {
      lines.push(
        "Frequency(Hz),Raw_SPL(dB),Smoothed_SPL(dB),Raw_Phase(deg),Smoothed_Phase(deg)",
      );
    } else {
      lines.push("Frequency(Hz),Raw_SPL(dB),Smoothed_SPL(dB)");
    }

    // Data rows
    const length = Math.min(
      data.frequencies.length,
      data.rawMagnitudes.length,
      data.smoothedMagnitudes.length,
    );

    for (let i = 0; i < length; i++) {
      const freq = data.frequencies[i].toFixed(2);
      const rawMag = data.rawMagnitudes[i].toFixed(3);
      const smoothedMag = data.smoothedMagnitudes[i].toFixed(3);

      if (hasPhase) {
        const rawPhase =
          data.rawPhase![i] !== undefined
            ? data.rawPhase![i].toFixed(1)
            : "0.0";
        const smoothedPhase =
          data.smoothedPhase![i] !== undefined
            ? data.smoothedPhase![i].toFixed(1)
            : "0.0";
        lines.push(
          `${freq},${rawMag},${smoothedMag},${rawPhase},${smoothedPhase}`,
        );
      } else {
        lines.push(`${freq},${rawMag},${smoothedMag}`);
      }
    }

    return lines.join("\n");
  }

  /**
   * Generate filename based on capture metadata
   */
  private static generateFilename(metadata: CaptureMetadata): string {
    const date = metadata.timestamp.toISOString().split("T")[0]; // YYYY-MM-DD
    const time = metadata.timestamp
      .toISOString()
      .split("T")[1]
      .split(".")[0]
      .replace(/:/g, "-"); // HH-MM-SS
    const channel = metadata.outputChannel.toLowerCase();
    const signalType = metadata.signalType;

    return `${date}_${time}_${channel}_${signalType}.csv`;
  }

  /**
   * Trigger browser download of CSV data
   */
  private static triggerDownload(csvContent: string, filename: string): void {
    try {
      // Create blob with CSV content
      const blob = new Blob([csvContent], { type: "text/csv;charset=utf-8;" });

      // Create temporary download link
      const link = document.createElement("a");
      const url = URL.createObjectURL(blob);

      link.href = url;
      link.download = filename;
      link.style.display = "none";

      // Append to body, trigger download, then remove
      document.body.appendChild(link);

      // Use setTimeout to ensure the element is in the DOM before clicking
      setTimeout(() => {
        link.click();

        // Clean up
        setTimeout(() => {
          document.body.removeChild(link);
          URL.revokeObjectURL(url);
        }, 100);
      }, 0);

      console.log(`CSV exported: ${filename}`);
    } catch (error) {
      console.error("Failed to trigger CSV download:", error);
      // Fallback: show the content in a new window if download fails
      const dataUri =
        "data:text/csv;charset=utf-8," + encodeURIComponent(csvContent);
      window.open(dataUri, "_blank");
    }
  }

  /**
   * Validate export data before processing
   */
  public static validateExportData(data: Partial<ExportData>): string[] {
    const errors: string[] = [];

    if (!data.frequencies || data.frequencies.length === 0) {
      errors.push("No frequency data available");
    }

    if (!data.rawMagnitudes || data.rawMagnitudes.length === 0) {
      errors.push("No raw magnitude data available");
    }

    if (!data.smoothedMagnitudes || data.smoothedMagnitudes.length === 0) {
      errors.push("No smoothed magnitude data available");
    }

    if (!data.metadata) {
      errors.push("No capture metadata available");
    }

    // Check data length consistency
    if (data.frequencies && data.rawMagnitudes && data.smoothedMagnitudes) {
      const freqLen = data.frequencies.length;
      const rawLen = data.rawMagnitudes.length;
      const smoothLen = data.smoothedMagnitudes.length;

      if (freqLen !== rawLen || freqLen !== smoothLen) {
        errors.push(
          `Data length mismatch: frequencies(${freqLen}), raw(${rawLen}), smoothed(${smoothLen})`,
        );
      }
    }

    return errors;
  }

  /**
   * Generate a preview of the CSV content (first few lines)
   */
  public static generatePreview(
    data: ExportData,
    maxLines: number = 10,
  ): string {
    const csv = this.generateCSV(data);
    const lines = csv.split("\n");
    const previewLines = lines.slice(0, Math.min(maxLines + 9, lines.length)); // +9 for header comments

    if (lines.length > previewLines.length) {
      previewLines.push(
        `... and ${lines.length - previewLines.length} more rows`,
      );
    }

    return previewLines.join("\n");
  }

  /**
   * Convert capture data to a format suitable for the optimization algorithm
   */
  public static toOptimizationFormat(data: ExportData): {
    frequencies: number[];
    magnitudes: number[];
  } {
    return {
      frequencies: [...data.frequencies],
      magnitudes: [...data.smoothedMagnitudes], // Use smoothed data for optimization
    };
  }
}
