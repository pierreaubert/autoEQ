<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Upmixer Demo</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@1.0.4/css/bulma.min.css">
    <style>
      body {
        margin: 0;
        padding: 20px;
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          "Helvetica Neue", Arial, sans-serif;
        background: #1a1a1a;
        color: #ffffff;
      }

      .demo-container {
        max-width: 1200px;
        margin: 0 auto;
      }

      h1 {
        margin-bottom: 20px;
        color: #00bfff;
      }

      .description {
        margin-bottom: 30px;
        padding: 15px;
        background: #2a2a2a;
        border-radius: 8px;
        line-height: 1.6;
      }

      #upmixer-container {
        min-height: 600px;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
      }

      .info {
        margin-top: 30px;
        padding: 15px;
        background: #2a2a2a;
        border-radius: 8px;
        border-left: 4px solid #00bfff;
      }

      .info h3 {
        margin-top: 0;
        color: #00bfff;
      }

      code {
        background: #1a1a1a;
        padding: 2px 6px;
        border-radius: 3px;
        font-family: "Courier New", monospace;
        color: #00ff88;
      }

      /* Ensure upmixer plugin styles are visible */
      .parameter-group label {
        color: #ffffff !important;
        text-align: center !important;
        font-size: 14px !important;
        font-weight: 600 !important;
      }

      .param-value {
        color: #00bfff !important;
        font-weight: 600 !important;
        font-size: 14px !important;
        grid-row: 5 !important;
        text-align: center !important;
      }

      .param-slider {
        width: 50px !important;
        grid-row: 3 !important;
      }

      .section-label {
        color: #ffffff !important;
        font-weight: 600;
        margin-bottom: 8px;
      }

      .meter-labels span,
      .meter-labels-output span {
        color: #ffffff !important;
        font-size: 12px;
      }

      .parameter-section h4 {
        color: #00bfff !important;
        margin-bottom: 16px;
      }

      .control-group {
        color: #ffffff !important;
      }

      .group-label {
        color: #ffffff !important;
      }

      /* Layout: put input meters, parameters, and output meters in a row */
      .upmixer-content {
        display: flex !important;
        flex-direction: row !important;
        align-items: flex-start !important;
        gap: 20px !important;
        padding: 20px !important;
      }

      .upmixer-input-section,
      .upmixer-parameters,
      .upmixer-output-section {
        flex: 1 !important;
        display: flex !important;
        flex-direction: column !important;
        align-items: center !important;
      }

      .upmixer-input-section,
      .upmixer-output-section {
        justify-content: flex-start !important;
      }

      .upmixer-parameters {
        flex: 2 !important;
        min-width: 300px !important;
      }

      /* Shorten host level meters */
      .level-meters-container {
        max-height: 250px !important;
      }

      .level-meters-container canvas {
        max-height: 200px !important;
      }

      /* Make parameter sliders vertical and larger */
      .parameter-group {
        display: grid !important;
        grid-template-rows: auto 10px 200px 10px auto !important;
        align-items: center !important;
        justify-items: center !important;
        margin: 0 !important;
        padding: 0 !important;
      }

      .parameter-group label {
        writing-mode: horizontal-tb !important;
        width: 100% !important;
        font-size: 12px !important;
        display: contents !important;
      }

      .param-slider {
        writing-mode: bt-lr !important;
        -webkit-appearance: slider-vertical !important;
        width: 50px !important;
        height: 200px !important;
        margin: 0 !important;
        padding: 0 !important;
        position: relative !important;
      }

      /* Position parameter groups to allow space for axis labels */
      .parameter-group {
        position: relative !important;
      }

      .param-value {
        font-size: 11px !important;
        margin-top: 4px !important;
      }

      .parameter-section {
        display: flex !important;
        flex-direction: row !important;
        gap: 20px !important;
        justify-content: space-around !important;
      }

      .parameter-section h4 {
        display: none !important;
      }

      /* Fix upmixer input meters size to match output meters */
      .upmixer-input-meters {
        width: 70px !important;
        height: 200px !important;
      }

      .upmixer-output-meters {
        width: 160px !important;
        height: 200px !important;
      }

      /* Remove margins from active plugin container */
      .active-plugin-container {
        margin-top: 0 !important;
        margin-left: 0 !important;
        margin-bottom: 0 !important;
        padding: 0 !important;
      }

      .upmixer-plugin {
        margin: 0 !important;
        padding: 0 !important;
        background: rgba(26, 26, 26, 1) !important;
      }

      .upmixer-content {
        background: rgba(26, 26, 26, 1) !important;
      }

      /* Ensure section labels and meter labels are visible */
      .section-label {
        color: #ffffff !important;
        font-weight: 600 !important;
        font-size: 14px !important;
        margin-bottom: 8px !important;
        display: block !important;
      }

      .meter-labels,
      .meter-labels-output {
        display: flex !important;
        justify-content: space-around !important;
        margin-top: 4px !important;
      }

      .meter-labels span,
      .meter-labels-output span {
        color: #ffffff !important;
        font-size: 11px !important;
        font-weight: 600 !important;
      }
    </style>
  </head>
  <body>
    <div class="demo-container">
      <h1>Upmixer Plugin Demo</h1>

      <div class="description">
        <p>
          <strong>Upmixer</strong> converts stereo audio (2 channels) into
          surround sound (5.0 channels: L, R, C, SL, SR). It uses FFT-based
          spatial processing to extract center and surround information from
          the stereo signal.
        </p>
        <p>
          This demo shows the upmixer plugin hosted in a simple plugin host
          with level meters, LUFS monitoring, and volume control.
        </p>
      </div>

      <div id="upmixer-container">
        <!-- Upmixer host will be rendered here -->
      </div>

      <div class="info">
        <h3>Output Channels</h3>
        <ul>
          <li><strong>L (Left):</strong> Left front speaker</li>
          <li><strong>R (Right):</strong> Right front speaker</li>
          <li><strong>C (Center):</strong> Center speaker (dialogue/vocals)</li>
          <li><strong>SL (Surround Left):</strong> Left rear speaker</li>
          <li><strong>SR (Surround Right):</strong> Right rear speaker</li>
        </ul>
        <h3>Parameters</h3>
        <ul>
          <li><strong>Center Width:</strong> Amount of center channel extraction</li>
          <li><strong>Surround Level:</strong> Level of surround channels</li>
          <li><strong>LFE Crossover:</strong> Low frequency cutoff for subwoofer (if enabled)</li>
        </ul>
        <h3>Use Cases</h3>
        <ul>
          <li>Creating surround mixes from stereo sources</li>
          <li>Home theater playback of stereo music</li>
          <li>Immersive audio experiences</li>
        </ul>
      </div>
    </div>

    <script type="module">
      import { PluginHost } from "../modules/plugins/host.ts";
      import { UpmixerPlugin } from "../modules/plugins/plugin-upmixer.ts";
      import { ShortcutsModal } from "../modules/plugins/shortcuts-modal.ts";

      // Get container
      const container = document.getElementById("upmixer-container");

      // Configure host
      const hostConfig = {
        name: 'Upmixer Demo',
        allowedPlugins: ['spatial'],  // Upmixer plugin has category 'spatial'
        maxPlugins: 1,
        showLevelMeters: true,
        showLUFS: true,
        showVolumeControl: true,
        menubarConfig: {
          showName: true,
          showPresets: true,
          showMatrix: true,
          showMuteSolo: true,
        },
      };

      // Create host
      const host = new PluginHost(container, hostConfig, {
        onPluginChange: (plugin) => {
          console.log("Plugin changed:", plugin.getName());
        },
        onParameterChange: (plugin, parameter, value) => {
          console.log(
            `Parameter changed: ${parameter.name} = ${value} in ${plugin.getName()}`
          );
        },
      });

      // Create and add upmixer plugin
      const upmixer = new UpmixerPlugin();
      host.addPlugin(upmixer);
      host.selectPlugin(upmixer);

      // Create shortcuts modal
      const shortcutsModal = new ShortcutsModal({
        pluginName: 'Upmixer',
        pluginShortcuts: [
          { key: 'Tab', description: 'Cycle through parameter sliders' },
          { key: 'Shift + ↑', description: 'Increase selected parameter by 0.25 dB' },
          { key: 'Shift + ↓', description: 'Decrease selected parameter by 0.25 dB' },
          { key: 'Esc', description: 'Deselect all sliders' },
        ],
        hostShortcuts: [
          { key: '↑', description: 'Increase volume' },
          { key: '↓', description: 'Decrease volume' },
          { key: '?', description: 'Show keyboard shortcuts' },
        ]
      });

      // Add modal to DOM
      const modalElement = shortcutsModal.createModal();
      document.body.appendChild(modalElement);

      // Add axis labels to sliders and clean up labels
      setTimeout(() => {
        // Remove "Level" from parameter labels
        const paramGroups = document.querySelectorAll('.parameter-group');
        paramGroups.forEach((group) => {
          const label = group.querySelector('label');
          if (label) {
            // Get text content (excluding the span with value)
            const textNode = Array.from(label.childNodes).find(node => node.nodeType === Node.TEXT_NODE);
            if (textNode) {
              textNode.textContent = textNode.textContent.replace(/\s*Level\s*/i, '').trim();
            }
          }
        });
        paramGroups.forEach((group) => {
          const slider = group.querySelector('.param-slider');
          if (slider) {
            const min = parseFloat(slider.getAttribute('min'));
            const max = parseFloat(slider.getAttribute('max'));
            const step = slider.getAttribute('data-param') === 'crossfeedAmount' ? 0.25 : 3;

            // Create axis labels container
            const axisContainer = document.createElement('div');
            axisContainer.className = 'slider-axis';
            axisContainer.style.position = 'absolute';
            axisContainer.style.right = '60px';
            axisContainer.style.height = '200px';
            axisContainer.style.display = 'flex';
            axisContainer.style.flexDirection = 'column';
            axisContainer.style.justifyContent = 'space-between';
            axisContainer.style.fontSize = '9px';
            axisContainer.style.color = '#888';
            axisContainer.style.pointerEvents = 'none';
            axisContainer.style.textAlign = 'right';
            axisContainer.style.paddingRight = '5px';

            // Generate labels based on slider type
            let labels;
            if (slider.getAttribute('data-param') === 'crossfeedAmount') {
              labels = ['100%', '75%', '50%', '25%', '0%'];
            } else {
              // dB scale from max to min
              const numLabels = 5;
              labels = [];
              for (let i = 0; i < numLabels; i++) {
                const value = max - (i * (max - min) / (numLabels - 1));
                labels.push(value.toFixed(0) + ' dB');
              }
            }

            labels.forEach(label => {
              const span = document.createElement('span');
              span.textContent = label;
              axisContainer.appendChild(span);
            });

            group.appendChild(axisContainer);
          }
        });

        // Replace output meter labels with Bulma tags
        const meterLabelsOutput = document.querySelector('.meter-labels-output');
        const meterCanvas = document.querySelector('.upmixer-output-meters');
        if (meterLabelsOutput && meterCanvas) {
          // Use the actual rendered width of the canvas
          const canvasWidth = meterCanvas.getBoundingClientRect().width;
          const numChannels = 6;
          const meterWidth = canvasWidth / numChannels;

          console.log('Canvas width:', canvasWidth, 'Meter width:', meterWidth);

          meterLabelsOutput.innerHTML = '';
          meterLabelsOutput.style.display = 'flex';
          meterLabelsOutput.style.justifyContent = 'flex-start';
          meterLabelsOutput.style.width = canvasWidth + 'px';
          meterLabelsOutput.style.marginTop = '8px';
          meterLabelsOutput.style.gap = '0';

          // Channel groups: [L+R] [C] [L] [SL+SR]
          // Each group width based on number of channels
          const groups = [
            { label: 'L+R', channels: 2, color: 'is-info' },
            { label: 'C', channels: 1, color: 'is-success' },
            { label: 'L', channels: 1, color: 'is-warning' },
            { label: 'SL+SR', channels: 2, color: 'is-danger' }
          ];

          groups.forEach(group => {
            const tag = document.createElement('span');
            tag.className = `tag is-small ${group.color}`;
            tag.textContent = group.label;
            tag.style.width = (meterWidth * group.channels) + 'px';
            tag.style.textAlign = 'center';
            tag.style.fontSize = '9px';
            tag.style.flexShrink = '0';
            meterLabelsOutput.appendChild(tag);
          });
        }

        // Restructure mute/solo controls
        const controlsContainer = document.querySelector('.upmixer-controls');
        if (controlsContainer && meterCanvas) {
          const canvasWidth = meterCanvas.getBoundingClientRect().width;
          const numChannels = 6;
          const meterWidth = canvasWidth / numChannels;

          // Get existing control groups
          const controlGroups = Array.from(controlsContainer.querySelectorAll('.control-group'));

          // Clear container
          controlsContainer.innerHTML = '';
          controlsContainer.style.display = 'flex';
          controlsContainer.style.flexDirection = 'column';
          controlsContainer.style.gap = '4px';
          controlsContainer.style.marginTop = '4px';

          // Channel groups matching labels
          const channelGroups = [
            { channels: 2, color: 'is-info', indices: [0] },      // L+R
            { channels: 1, color: 'is-success', indices: [1] },   // C
            { channels: 1, color: 'is-warning', indices: [2] },   // LFE
            { channels: 2, color: 'is-danger', indices: [3] }     // SL+SR
          ];

          // Create mute row
          const muteRow = document.createElement('div');
          muteRow.style.display = 'flex';
          muteRow.style.justifyContent = 'flex-start';
          muteRow.style.width = canvasWidth + 'px';
          muteRow.style.gap = '0';

          channelGroups.forEach(group => {
            const container = document.createElement('div');
            container.style.width = (meterWidth * group.channels) + 'px';
            container.style.display = 'flex';
            container.style.justifyContent = 'center';
            container.style.flexShrink = '0';

            group.indices.forEach(idx => {
              if (controlGroups[idx]) {
                const muteBtn = controlGroups[idx].querySelector('.mute-btn').cloneNode(true);
                muteBtn.className = `tag is-small ${group.color} mute-btn`;
                muteBtn.textContent = 'M';
                muteBtn.style.cursor = 'pointer';
                muteBtn.style.fontSize = '9px';
                muteBtn.style.border = 'none';
                container.appendChild(muteBtn);
              }
            });

            muteRow.appendChild(container);
          });

          // Create solo row
          const soloRow = document.createElement('div');
          soloRow.style.display = 'flex';
          soloRow.style.justifyContent = 'flex-start';
          soloRow.style.width = canvasWidth + 'px';
          soloRow.style.gap = '0';

          channelGroups.forEach(group => {
            const container = document.createElement('div');
            container.style.width = (meterWidth * group.channels) + 'px';
            container.style.display = 'flex';
            container.style.justifyContent = 'center';
            container.style.flexShrink = '0';

            group.indices.forEach(idx => {
              if (controlGroups[idx]) {
                const soloBtn = controlGroups[idx].querySelector('.solo-btn').cloneNode(true);
                soloBtn.className = `tag is-small ${group.color} solo-btn`;
                soloBtn.textContent = 'S';
                soloBtn.style.cursor = 'pointer';
                soloBtn.style.fontSize = '9px';
                soloBtn.style.border = 'none';
                container.appendChild(soloBtn);
              }
            });

            soloRow.appendChild(container);
          });

          controlsContainer.appendChild(muteRow);
          controlsContainer.appendChild(soloRow);
        }
      }, 100);

      // Keyboard navigation for sliders
      let selectedSliderIndex = -1;
      const sliders = Array.from(document.querySelectorAll('.param-slider'));

      function updateSliderHighlight() {
        sliders.forEach((slider, idx) => {
          if (idx === selectedSliderIndex) {
            slider.style.accentColor = '#48c774'; // Green color
          } else {
            slider.style.accentColor = ''; // Reset to default
          }
        });
      }

      document.addEventListener('keydown', (e) => {
        // ? key to show shortcuts modal
        if (e.key === '?' && !shortcutsModal.isVisible()) {
          e.preventDefault();
          shortcutsModal.show();
          return;
        }

        // Don't handle other shortcuts if modal is visible
        if (shortcutsModal.isVisible()) {
          return;
        }

        // TAB to cycle through sliders
        if (e.key === 'Tab') {
          e.preventDefault();
          selectedSliderIndex = (selectedSliderIndex + 1) % sliders.length;
          updateSliderHighlight();
          return;
        }

        // ESC to deselect all sliders
        if (e.key === 'Escape') {
          selectedSliderIndex = -1;
          updateSliderHighlight();
          return;
        }

        // Shift+Arrow keys to adjust selected slider
        if ((e.key === 'ArrowUp' || e.key === 'ArrowDown') && e.shiftKey) {
          if (selectedSliderIndex >= 0 && selectedSliderIndex < sliders.length) {
            e.preventDefault();
            e.stopPropagation();

            const slider = sliders[selectedSliderIndex];
            const currentValue = parseFloat(slider.value);
            const min = parseFloat(slider.min);
            const max = parseFloat(slider.max);
            const step = slider.getAttribute('data-param') === 'crossfeedAmount' ? 0.01 : 0.25;

            if (e.key === 'ArrowUp') {
              const newValue = Math.min(max, currentValue + step);
              slider.value = newValue.toString();
              slider.dispatchEvent(new Event('input', { bubbles: true }));
            } else if (e.key === 'ArrowDown') {
              const newValue = Math.max(min, currentValue - step);
              slider.value = newValue.toString();
              slider.dispatchEvent(new Event('input', { bubbles: true }));
            }
          }
        }
        // Arrow keys without Shift -> let volume control handle it (do nothing here)
      });

      // Log info
      console.log("Upmixer demo initialized");
      console.log("Plugins:", host.getPlugins().map(p => p.metadata.name));
      console.log("Note: Upmixer converts 2ch stereo to 5ch surround (L, R, C, SL, SR)");
      console.log("Keyboard shortcuts: TAB to select slider, Arrow Up/Down to adjust");
    </script>
  </body>
</html>
